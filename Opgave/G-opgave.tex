\documentclass[a4paper,11pt]{article}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pslatex}
\usepackage[danish]{babel}
\usepackage{graphics}

\title{En oversætter for 100}

\author{Godkendelsesopgave på kurset Oversættere}

\date{Vinter 2011/12}

\begin{document}

%\setlength{\baselineskip}{0.95\baselineskip}

\maketitle

\section{Introduktion}

Dette er projektopgaven på Oversættere, vinter 2011 -- 2012.  Opgaven
skal løses i grupper på op til 3 personer.  Opgaven bliver stillet
mandag d.\ 21/11 2011 og skal afleveres senest fredag d.\ 22/12 2011.
Opgaven afleveres via kursushjemmesiden på Absalon.  Brug
gruppeafleveringsfunktionen i Absalon.  Alle medlemmer af gruppen skal
på rapportforsiden angives med navn.  Der er ikke lavet en
standardforside, så lav en selv.

Projektopgaven bedømmes som godkendt / ikke godkendt.  Godkendelse af
denne opgave er (sammen med godkendelse af mindst fire ud af de fem
ugeopgaver) en forudsætning for deltagelse i den karaktergivende
eksamensopgave, der løses individuelt.  En ikke-godkendt
godkendelsesopgave kan {\em ikke} genafleveres.

\section{Om opgaven}

Opgaven går ud på at implementere en oversætter for sproget 100, som
er beskrevet i afsnit~\ref{cat}.

Som hjælp hertil gives en fungerende implementering af en delmængde af
100.  I afsnit~\ref{subset} er denne delmængde beskrevet.

Der findes på kursussiden en zip-fil kaldet ``G.zip'', der indeholder
opgaveteksten, implementeringen af delmængden af 100 samt et antal
testprogrammer med input og forventet output. Der kan blive lagt flere
testprogrammer ud i løbet af de første uger af opgaveperioden.

Det er nødvendigt at modificere følgende filer:
 
\begin{description}

\item[{\tt Parser.grm}] Grammatikken for 100 med parseraktioner, der
  opbygger den abstrakte syntaks.

\item[{\tt Lexer.lex}] Leksikalske definitioner for {\em tokens} i
  100.

\item[{\tt Type.sml}] Typechecker for 100.

\item[{\tt Compiler.sml}] Oversætter fra 100 til MIPS assembler.
  Oversættelsen sker direkte fra 100 til MIPS uden brug af
  mellemkode.

\end{description}

\noindent
Andre moduler indgår i oversætteren, men det er ikke nødvendigt at
ændre disse.

Til oversættelse af ovennævnte moduler (og andre moduler, der ikke
skal ændres) bruges Moscow-ML oversætteren inklusive værktøjerne
MosML-lex og MosML-yacc.  {\tt Compiler.sml} bruger datastruktur og
registerallokator for en delmængde af MIPS instruktionssættet.
Filerne {\tt compile.sh} og {\tt compile.bat} indeholder kommandoer
for hhv.\ Linux og Windows til oversættelse af de nødvendige moduler.
Der vil optræde nogle {\em warnings} fra compileren.  Disse kan
ignoreres, men vær opmærksom på evt.\ nye fejlmeddelelser eller
advarsler, når I retter i filerne.

Til afvikling af de oversatte MIPS programmer bruges simulatoren
MARS.  Der er link til denne fra kursets Absalonside.

\subsection*{Krav til besvarelsen}

Besvarelsen afleveres som en PDF fil med rapporten samt en zip-fil,
der indeholder og alle relevante program- og datafiler, sådan at man
ved at pakke zip-filen ud i et ellers tomt katalog kan oversætte og
køre oversætteren på testprogrammerne.  Dette kan f.eks.\ gøres ved,
at I zipper hele jeres arbejdskatalog (og evt.\ underkataloger).

Filerne afleveres via kursushjemmesiden.  Brug gruppeaflevering -- der
skal {\em ikke} afleveres en kopi pr.\ gruppemedlem.

Rapportforsiden skal angive alle medlemmer af gruppen med navn.

Rapporten skal indeholde en begrundet beskrivelse af de ændringer, der
laves i ovenstående komponenter.

For {\tt Parser.grm} skal der kort forklares hvordan grammatikken er
gjort entydig (ved omskrivning eller brug af
operatorpræcedenserklæringer) samt beskrivelse af eventuelle
ikke-åbenlyse løsninger, f.eks.\ i forbindelse med opbygning af
abstrakt syntaks. Det skal bemærkes, at alle konflikter skal fjernes
v.h.a.\ præcedenserklæringer eller omskrivning af syntaks.  Med andre
ord må MosML-yacc {\em ikke} rapportere konflikter i tabellen.

For {\tt Type.sml} og {\tt Compiler.sml} skal kort beskrives, hvordan
typerne checkes og kode genereres for de nye konstruktioner.  Brug
evt.\ en form, der ligner figur~6.2 og 7.3 i {\em Basics of Compiler
Design}.

Der vil primært lægges vægt på, at sproget implementeres korrekt, men
effektivitet af den genererede kode kan også inddrages.  Optimeringer
af særtilfælde vægtes ikke særligt højt, men omtanke omkring den
almindelige kodegenerering gør.  Hvis der er åbenlyse ineffektiviteter
ved generering af almindelig kode, vil forsøg på optimeringer af
særtilfælde ligefrem kunne trække ned, da det vidner om forkert
prioritering eller manglende forståelse.

I skal ikke inkludere hele programteksterne i rapportteksten, men I
skal inkludere de væsentligt ændrede eller tilføjede dele af
programmerne i rapportteksten som figurer, bilag e.lign.  Hvis I
henviser til dele af programteksten, skal disse dele inkluderes i
rapporten.

Rapporten skal beskrive hvorvidt oversættelse og kørsel af
eksempelprogrammer (jvf.\ afsnit~\ref{eksempelprogrammer}) giver den
forventede opførsel, samt beskrivelse af afvigelser derfra.  Endvidere
skal det vurderes, i hvilket omfang de udleverede testprogrammer er
dækkende og der skal laves nye testprogrammer, der dækker de største
mangler ved testen.

Kendte mangler i typechecker og oversætter skal beskrives, og i det
omfang det er muligt, skal der laves forslag til hvordan disse evt.\
kan udbedres.

Det er i stort omfang op til jer selv at bestemme, hvad I mener er
væsentligt at medtage i rapporten, sålænge de eksplicitte krav i dette
afsnit er opfyldt.

Rapporten bør holdes under 16 sider.  Al væsentlig information om
løsningen bør medtages i rapporten, så man i det væsentlige ikke
behøver at læse jeres kildekode.  Men for mange irrelevante detaljer
og udenomssnak vil trække ned.  Alle væsentlige designbeslutninger
skal dog beskrives og begrundes, og alle fejl og mangler skal
beskrives.


\subsection{Afgrænsninger af oversætteren}

Det er helt i orden, at lexer, parser, typechecker og kodegenerator
stopper ved den første fundne fejl.

Hovedprogrammet {\tt CC.sml} kører typecheck på programmerne inden
oversætteren kaldes, så oversætteren kan antage, at programmerne er
uden typefejl m.m.

Det kan antages, at de oversatte programmer er små nok til, at alle
hopadresser kan ligge i konstantfelterne i branch- og hopordrer og at
tupler er så små, at størrelse og {\em offsets} kan ligge i
konstantfeltet i en instruktion.

Det ikke nødvendigt at frigøre lager i hoben mens programmet kører.
Der skal ikke laves test for overløb på stakken eller hoben.  Den
faktiske opførsel ved overløb er udefineret, så om der sker fejl under
afvikling eller oversættelse, eller om der bare beregnes mærkelige
værdier, er underordnet.

\subsection{MosML-Lex og MosML-yacc}

Beskrivelser af disse værktøjer findes i Moscow ML's Owners Manual,
som kan hentes via kursets hjemmeside. Yderligere information samt
installationer af systemet til Windows og Linux findes på Moscow ML's
hjemmeside (følg link fra kursets hjemmeside, i afsnittet om
programmel).  Desuden er et eksempel på brug af disse værktøjer
beskrevet i en note, der kan findes i {\tt Lex+Parse.zip}, som er
tilgængelig via kursets hjemmeside.


\section{100\label{cat}}

100 er et simpelt imperativt programmeringssprog inspireret af C.

Herunder beskrives syntaks og uformel semantik for sproget 100 og en
kort beskrivelse af de filer, der implementerer sproget.

\section{Syntaks}

\begin{figure}
\[\renewcommand{\arraystretch}{0.87}
\begin{array}{lcl}
Prog & \rightarrow & FunDecs \\[0.9ex]

FunDecs & \rightarrow
       & Type~Sid~\texttt{(} ~Decs~\texttt{)}~Stat~FunDecs \\
FunDecs & \rightarrow & \\[0.9ex]

Type & \rightarrow & \mbox{\tt int} \\
Type & \rightarrow & \mbox{\tt char} \\[0.9ex]

Decs & \rightarrow & \\
Decs & \rightarrow & Decs1~Dec \\[0.9ex]

Decs1 & \rightarrow &  \\
Decs1 & \rightarrow & Decs1~Dec~\texttt{;} \\[0.9ex]

Dec  & \rightarrow & Type ~Sids \\[0.9ex]

Sids  & \rightarrow & Sid \\
Sids  & \rightarrow & Sid~\texttt{,}~Sids \\[0.9ex]

Sid & \rightarrow & \textbf{id} \\
Sid & \rightarrow & \texttt{*}~\textbf{id}  \\[0.9ex]

Stats & \rightarrow & \\
Stats & \rightarrow & Stat Stats\\[0.9ex]

Stat & \rightarrow & Exp ~\texttt{;}\\
Stat & \rightarrow & \texttt{if~(}~Exp~\texttt{)}~Stat \\
Stat & \rightarrow & \texttt{if~(}~Exp~\texttt{)}~Stat~\texttt{else}~Stat \\
Stat & \rightarrow & \texttt{while~(}~Exp~\texttt{)}~Stat \\
Stat & \rightarrow & \texttt{return}~Exp~\texttt{;}\\
Stat & \rightarrow & \texttt{\{}~Decs1~Stats~\texttt{\}} \\[0.9ex]

Exp & \rightarrow & \textbf{numConst} \\
Exp & \rightarrow & \textbf{charConst} \\
Exp & \rightarrow & \textbf{stringConst} \\
Exp & \rightarrow & Lval \\
Exp & \rightarrow & Lval~\texttt{=}~Exp \\
Exp & \rightarrow & Exp~\texttt{+}~Exp \\
Exp & \rightarrow & Exp~\texttt{-}~Exp \\
Exp & \rightarrow & Exp~\texttt{<}~Exp \\
Exp & \rightarrow & Exp~\texttt{==}~Exp \\
Exp & \rightarrow & \texttt{(}~Exp~\texttt{)}\\
Exp & \rightarrow & \textbf{id}~\texttt{(}~Exps~\texttt{)}\\
Exp & \rightarrow & \texttt{(}~Exp~\texttt{)} \\[0.9ex]

Exps & \rightarrow & \\
Exps & \rightarrow & Exps1 \\[0.9ex]

Exps1  & \rightarrow & Exp \\
Exps1 & \rightarrow & Exp~\texttt{,}~Exps1 \\[0.9ex]

Lval & \rightarrow & \textbf{id} \\
Lval & \rightarrow & \textbf{id}~\texttt{*}\\
Lval & \rightarrow & \textbf{id}~\texttt{[}~Exp~\texttt{]}
\end{array}
\renewcommand{\arraystretch}{1.0}
\]
\caption{Syntaks for 100\label{syntaks}}
\end{figure}

\subsection{Leksikalske og syntaktiske detaljer}

\begin{itemize}
  
\item Et navn ({\bf id}) består af bogstaver (både store og små),
  cifre og understreger og skal starte med et bogstav.  Bogstaver er
  engelske bogstaver, dvs.\ fra A til Z og a til z.  Nøgleord som
  f.eks.\ {\tt if} er {\em ikke} legale navne.
  
\item Talkonstanter ({\bf numConst}) er ikke-tomme følger af cifrene
  0-9.  Talkonstanter er begrænset til tal, der kan repræsenteres som
  positive heltal i Moscow ML.

\item En tegnkonstant ({\bf charConst}) består af en tegnspecifikator
  omgivet af enkelte anførselstegn (\texttt{'}).  En tegnspecifikator
  kan være en af følgende:

  \begin{enumerate}
  \item Et tegn med ASCII kode mellem 32 og 126 \emph{undtagen}
    tegnene \texttt{'}, \texttt{"} og \verb`\`.
  \item Tegnet \verb`\` efterfulgt af et tegn med ASCII kode mellem 32
    og 126.
  \end{enumerate}

  Kun tegnspecifikationer, der er lovlige i C, er tilladt.

\item En stringkonstant ({\bf stringConst}) består af en sekvens af
  tegnspecifikatorer omgivet af dobbelte anførselstegn (\texttt{"}).
  
\item Operatorerne {\tt +} og {\tt -} har samme præcedens og
  er begge venstreassociative.

\item Operatorerne {\tt <} og {\tt ==} har samme præcedens og er begge
  venstreassociative.  De binder begge svagere end {\tt +}.

\item Tildelingsoperatoren {\tt =} binder svagere end {\tt <} og er
  højreassociativ.

\item {\tt else} binder til nærmeste \texttt{if} som beskrevet i
  lærebogen.

\item Der er separate navnerum for variabler og funktioner.

\item Kommentarer starter med {\tt /*} og slutter med {\tt */}.
  Mellem disse kan være vilkårlige tegn som ikke indeholder sekvensen
  {\tt */}.

\end{itemize}

\section{Semantik}

Hvor intet andet er angivet, er semantikken for de forskellige
konstruktioner i sproget identisk med semantikken for tilsvarende
konstruktioner i C.

Et 100 program består af funktionserklæringer.  Der skal være en
funktion med navn \texttt{main} som ikke har nogen parametre og hvor
returtypen er \texttt{int}.  Kørsel af et program sker ved kald til
denne funktion.  Alle funktioner har virkefelt i hele programmet, så
de er gensidigt rekursive.  Der må ikke erklæres to funktioner med
samme navn.  Bemærk, at 100 her adskiller sig fra C, hvor kun
funktioner, der er erklæret tidligere kan ses, og hvor det er muligt
at omdefinere funktioner.

Udover heltal (typen {\tt int}) og tegn (typen {\tt char}) har 100
også referencer.  En variabel \texttt{x} erklæret som \texttt{int~*x}
er f.eks.\ en reference til et heltal.  Den bagvedstillede operator
\texttt{*} følger en reference til dens indhold.  Referencer kan
bruges som tabeller, så hvis f.eks.\ \texttt{x} er erklæret som
\texttt{int~*x} vil \texttt{x[7]} referere til det heltal, der ligger
7 maskinord efter det maskinord, som \texttt{x} peger på, og hvis
\texttt{s} er erklæret som \texttt{char~*s} vil \texttt{s[7]} referere
til det tegn, der ligger 7 bytes efter den byte, som \texttt{s} peger
på.  Bemærk, at kodegenerering af et udtryk af formen \texttt{x[$e$]}
kræver kendskab til typen af \texttt{x}.  Det er udefineret, hvad der
sker, hvis man bruger offsets udenfor det område, der er allokeret til
referencen/tabellen.  Endvidere er det udefineret, hvad der sker, hvis
man følger referencen i en uinitialiseret referencevariabel.

I udtryk gøres ikke forskel på tegn (\texttt{char}) og heltal
(\texttt{int}): De repræsenteres begge som heltal.  Det er kun, når
værdier gemmes og hentes i variabler eller tabeller, at der gøres
forskel: Når der hentes og gemmes i tegnvariabler eller tegntabeller
overføres 8 bit, mens der overføres 32 bit, når der hentes og gemmes i
heltalsvariabler eller heltalstabeller.  Referencevariabler fylder
også 32 bit, men konverteres ikke automatisk til eller fra heltal.

Bemærk, at det betyder, at et udtryk af type \texttt{int} er et
lovligt argument til en funktion, der har en parameter af type
\texttt{char}.  Alle parametre overføres som hele maskinord i registre
eller lager, men kun de mindst betydende 8 bit af \texttt{char}
parametre bruges.

En tegnreference kan også ses som en string bestående af alle tegn fra
det, referencen peger på, frem til den nærmeste nulbyte.  En
stringkonstant er en reference til en string, der indeholder de
angivne tegn og afsluttes med en nulbyte.  Tegnet \verb`\` bruges i
tegn- og stringkonstanter som escape-tegn, der indkoder tegn, der
ellers ikke er lovlige i en tegnkonstant.  De tegn, der kan komme
efter et \verb`\` er de samme som i C.  Det er udefineret, hvad der
sker, hvis indholdet af en stringkonstant modificeres på køretid.

Operatoren \texttt{+} kan tage både heltal og referencer som
argumenter.  Reglerne er:

\begin{itemize}
\item Hvis begge argumenter er heltal, er resultatet et heltal.
\item Hvis det ene argument er et heltal $n$ og det andet er en
  heltalsreference $r$, er resultatet en reference til et heltal, der
  er $n$ maskinord efter det, som $r$ peger på.
\item Hvis det ene argument er et heltal $n$ og det andet er en
  tegnreference $r$, er resultatet en reference til et tegn, der er
  $n$ byte efter det, som $r$ peger på.
\item Hvis begge argumenter er referencer, er det en typefejl.
\end{itemize}

\noindent
Operatoren \texttt{-} kan tage både heltal og referencer som
argumenter.  Reglerne er:

\begin{itemize}
\item Hvis begge argumenter er heltal, er resultatet et heltal.
\item Hvis det første argument er et heltal og det andet er en
  reference, er det en typefejl.
\item Hvis det første argument er en heltalsreference $r$ og det andet
  argument er et heltal $n$, er resultatet en reference til et heltal,
  der er $n$ maskinord før det, som $r$ peger på.
\item Hvis det første argument er en tegnreference $r$ og det andet
  argument er et heltal $n$, er resultatet en reference til et tegn,
  der er $n$ bytes før det, som $r$ peger på.
\item Hvis begge argumenter er heltalsreferencer, er resultatet et
  heltal, der angiver antallet af maskinord mellem de to referencer.
\item Hvis begge argumenter er tegnreferencer, er resultatet et
  heltal, der angiver antallet af bytes mellem de to referencer.
\item Hvis de to argumenter er referencer af forskellig type, er det
  en typefejl.
\end{itemize}

\noindent
Bemærk, at den genererede kode for \texttt{+} og \texttt{-} afhænger
af typen af argumenterne, så man skal i oversætteren holde styr på
typen af udtryk, selv om dette allerede er gjort i typecheckeren.

Operatorerne \texttt{<} og \texttt{==} kan tage både heltal og
referencer som argumenter.  Begge argumenter skal være af samme type.
Hvis sammenligningen er sand, returneres tallet 1, ellers tallet 0.

Tildelingen $l\,\texttt{=}\,e$ beregner $l$ til enten en variabel eller
en adresse og beregner $e$ til en værdi, som lægges i variablen eller
adressen.  Værdien af tildelingen er den gemte værdi.  Hvis $l$ er en
heltalsvariabel, et element i en heltalstabel eller indholdet af en
heltalsreference, skal $e$ være et heltalsudtryk.  Hvis $l$ er en
tegnvariabel, et element i en tegntabel eller tegnreference, skal $e$
være et heltalsudtryk, men kun de sidste 8 bit af værdien af $e$
gemmes i $l$.  Hvis $l$ er en referencevariabel skal $e$ beregne en
reference af den samme type.  Alle disse begrænsninger skal checkes
i typecheckeren.

Betingelser i \texttt{if} og \texttt{while} sætninger er udtryk af
heltalstype og betragtes som sande, hvis deres værdi er forskellig fra
0.  Både \texttt{if} og \texttt{while} sætninger fungerer på samme
måde som i C.

I en variabelerklæring ($Decs$ eller $Decs1$) må det samme navn ikke
forekomme flere gange (dette skal checkes), men forskellige
erklæringer kan godt erklære variable med samme navn.  Variable, der
er erklæret i en erklæring lige efter et \texttt{\{} har virkefelt
(\emph{scope}) indtil det matchende \texttt{\}}.  Parametre til en
funktion har virkefelt i kroppen af funktionen.

Det betragtes som en fejl, hvis en funktion kan afslutte uden at
udføre en \texttt{return} sætning.  Typecheckeren skal angive fejl,
hvis dette er muligt, eller hvis typen af et udtryk, der er angivet
efter \texttt{return}, ikke har samme type som funktionens erklærede
resultattype.  Man kan antage, at alle betingelser i \texttt{if}- og
\texttt{while}-sætninger kan være både sande og falske, så hvis der
f.eks.\ ikke er en \texttt{return}-sætning efter en
\texttt{if-else}-sætning, skal begge grene af
\texttt{if-else}-sætningen indeholde en \texttt{return}-sætning.

Der er et antal foruddefinerede funktioner, der kan kaldes fra
programmet:

\begin{itemize}
\item \texttt{walloc()} tager et heltal $n$ og returnerer en
  \textit{word-aligned} reference til mindst $n$ maskinord, der er
  allokeret på hoben.  Returtypen er \texttt{int *}.
\item \texttt{balloc()} tager et heltal $n$ og returnerer en reference
  til mindst $n$ bytes, der er allokeret på hoben.  Returtypen er
  \texttt{char *}.
\item \texttt{getint()} tager ingen argumenter men returnerer et
  heltal, der er læst fra standard input.
\item \texttt{getstring()} tager et heltal $n$ som argument og
  returnerer en hob-allokeret string, der indeholder op til $n{-}1$ tegn
  læst fra standard input efterfulgt af en nul-byte.  Der læses kun
  frem til og med nærmeste linjeskift.  Hvis linjen slutter inden, der
  er læst $n{-}1$ tegn, læses frem til og med linjeskiftet og der
  tilføjes derefter et nul-byte.  Uanset dette allokeres mindst $n$
  byte på hoben til indholdet.
\item \texttt{putint()} tager et heltal som argument og skriver det ud
  på standard output.  Resultatet er det samme som argumentet.
\item \texttt{putstring()} tager en string som argument og skriver det
  ud på standard output.  Resultatet er det samme som argumentet.
\end{itemize}

\noindent
Kode for disse funktioner skal tilføjes koden for det oversatte
program.  Brug de systemkald for i/o, der er beskrevet i
dokumentationen til SPIM i bogen \textit{Computer Organisation \&
  Design}, som blev brugt på arkitekturkurset.  Bemærk, at denne
dokumentation kan downloades fra kursussiden.

Navne på foruddefinerede funktioner er ikke er nøgleord, så variable
kan godt hedde det samme.  Der kan dog ikke defineres nye funktioner
med disse navne.

\section{En delmængde af 100\label{subset}}

Den udleverede oversætter håndterer kun en delmængde af 100.
Begrænsningerne er som følger:

\begin{itemize}

\item Referencer, referencetyper og alle operationer på referencer er
  ikke implementeret.

\item Typen \texttt{char} og alle operationer på tegn er ikke
  implementeret.

\item Sammenligningsoperatoren \texttt{==} er ikke implementeret.

\item Løkker og blokke (\{ \ldots \}) er ikke implementeret.

\item Der checkes ikke om \texttt{return}-sætninger returnerer samme
  type som funktionen eller om en funktion kan afslutte uden at komme
  til en \texttt{return}-sætning.

\end{itemize}

Bemærk, at filen {\tt S100.sml} har abstrakt syntaks for resten af
sproget i kommentarer.

\section{Abstrakt syntaks og oversætter}

Filen {\tt S100.sml} angiver datastrukturer for den abstrakte
syntaks for programmer i 100.  Hele programmet har type {\tt
  S100.Prog}.

Filen {\tt C100.sml} indeholder et program, der kan indlæse,
typechecke og oversætte et 100-program.  Det kaldes ved at angive
filnavnet for programmet (uden extension) på kommandolinien,
f.eks. {\tt C100 fib}.  Extension for 100-programmer er {\tt .100},
f.eks.\ {\tt fib.100}.  Når 100-programmet er indlæst og checket,
skrives den oversatte kode ud på en fil med samme navn som programmet
men med extension {\tt .asm}. Kommandoen ``{\tt C100 fib}'' vil altså
tage en kildetekst fra filen {\tt fib.100} og skrive kode ud i filen
{\tt fib.asm}.

Den symbolske oversatte kode kan indlæses og køres af MARS.
Kommandoen ``{\tt java -jar Mars.jar fib2.asm}'' vil køre programmet
og læse inddata fra standard input og skrive uddata til standard
output.  Lav evt.~ en makro til denne kommando.

Checkeren er implementeret i filerne {\tt Type.sig} og {\tt
Type.sml}.  Oversætteren er implementeret i filerne {\tt Compiler.sig}
og {\tt Compiler.sml}.

Hele oversætteren kan i Linux og MacOS genoversættes (inklusive
generering af lexer og parser) ved at skrive {\tt source compile.sh}
på kommandolinien (mens man er i et katalog med alle de relevante
filer, inclusive {\tt compile.sh}).  I Windows bruges {\tt
  compile.bat} i stedet.

Som hjælp til debugging af parser kan man bruge programmet {\tt
  SeeSyntax.sml}.  Hvis man kører dette program i det interaktive
system ({\tt mosml~SeeSyntax.sml}) kan man bruge funktionen {\tt
  showsyntax} med et filnavn som argument, og se ML datastrukturen for
den abstrakte syntaks.

\section{Eksempelprogrammer\label{eksempelprogrammer}}

Der er givet en række eksempelprogrammer skrevet i 100:

\begin{description}

\item[{\tt fib.100}] indlæser et ikke-negativt tal $n$ og udskriver
  $fib(n)$, hvor $fib$ er Fibonacci's funktion.

\item[\texttt{copy.100}] kopierer 14 tegn fra input til output.

\item[\texttt{charref.100}] læser et tal $i$ og en string $s$ ind og
  udskriver ASCII-koden for det $(i{-}1)$'te tegn i $s$.  Er medtaget
  fordi en funktion returnerer en tegnreference.

\item[\texttt{sort.100}] indlæser et tal $n$ og derefter $n$ tal, som
  sorteres og skrives ud.

\item[\texttt{sort2.100}] gør det samme som \texttt{sort.100}, men
  bruger referencearitmetik.

\item[\texttt{ssort.100}] indlæser en string $s$, sorterer tegnene i
  denne og skriver resultatet ud.

\item[\texttt{ssort2.100}] gør det samme som \texttt{ssort.100}, men
  bruger referencearitmetik.

\item[texttt{dfa.100}] læser et binært tal ind og skriver dets
  divisionsrest modulo 3 ud.

\end{description}

\noindent
Hvert eksempelprogram {\em
program}{\tt .100} skal oversættes og køres på inddata, der er givet i
filen {\em program}{\tt .in}.  Uddata fra kørslen af et program skal
stemme overens med det, der er givet i filen {\em program}{\tt .out}.
Hvis der ikke er nogen {\em program}{\tt .in} fil, køres programmet
uden inddata.

Der er endvidere givet et antal nummererede testprogrammer ({\tt
  error01.100, \ldots, error15.100}), der indeholder diverse fejl
eller inkonsistenser, der skal fanges i checkeren.  Der er ikke input-
eller outputfiler til disse programmer.

Kun {\tt fib.100} kan oversættes med den udleverede oversætter.  De
andre programmer bruger de manglende sprogelementer, og vil derfor
give fejl allerede under lexing eller parsing.

Selv om testprogrammerne kommer godt rundt i sproget, kan de på ingen
måde siges at være en udtømmende test hverken af normal kørsel eller
fejlsituationer.  Vurder, om der er ting i oversætteren, der ikke er
testet, og lave yderligere testprogrammer efter behov.  Hvis
bedømmerne finder en fejl i jeres kode, som ville være afsløret af et
simpelt ekstra testprogram, vil det trække ned.  Derimod vil det give
bonus, hvis ekstra testprogrammer afslører fejl, som sidenhen rettes.
Beskrive gerne dette i jeres testafsnit.
  
\section{Milepæle}

Da opgaven først skal afleveres efter fem uger, kan man fristes til at
udskyde arbejdet på opgaven til sidst i perioden.  Dette er en meget
dårlig ide.  Herunder er angivet retningslinier for hvornår de
forskellige komponenter af oversætteren bør være færdige, inklusive de
dele af rapporten, der beskriver disse.

\begin{description}
  
\item[Uge 47] Lexeren kan genereres og oversættes (husk at erklære de
nye tokens i parseren).  Rapportafsnit om lexer skrives.
  
\item[Uge 48] Parseren kan genereres og oversættes.  Rapportafsnit om
lexer og parser skrives.
  
\item[Uge 49] Typecheckeren er implementeret.  Rapportafsnit om
  typechecker skrives.
  
\item[Uge 50] Oversætteren er implementeret, rapportafsnit om denne
  skrives.

\item[Uge 51] Afsluttende afprøvning og rapportskrivning, rapporten
  afleveres om torsdagen.

\end{description}

\noindent
Bemærk, at typechecker og kodegenerering er væsentligt større opgaver
end lexer og parser.  Lexeren kan udvides og genereres på en times tid
og parseren på 2--3 timer.  Typecheckeren vil nok kræve 5--8 timers
fuldtidsarbejde og kodegeneratoren 10--20 timer.  Her er ikke
medregnet tid til at læse op på stoffet i bogen -- tiderne
forudsætter, at man har nogenlunde styr på de relevante dele af
pensum.

Efter hvert af de ovenstående skridt bør man genoversætte hele
oversætteren og prøvekøre den for testprogrammerne.  De endnu ikke
udvidede moduler kan ved oversættelse rapportere om ikke-udtømmende
pattern-matching, og ved køretid kan de rejse undtagelsen ``Match''.
Man kan i {\tt C100.sml} udkommentere kald til de senere faser for at
afprøve sprogudvidelserne for de moduler (faser), der allerede er
implementerede.

Jeres instruktor vil gerne løbende læse og komme med feedback til
afsnit af rapporten.  I skal dog regne med, at der kan gå noget tid,
inden I får svar (så bed ikke om feedback lige før
afleveringsfristen), og I skal ikke forvente, at et afsnit bliver læst
igennem flere gange.

\section{Vink}

\begin{itemize}

\item {\bf KISS}: {\em Keep It Simple, Stupid}.  Lav ikke avancerede
  løsninger, før I har en fungerende simpel løsning, inklusive udkast
  til et rapportafsnit, der beskriver denne.  Udvidelser og
  forbedringer kan derefter tilføjes og beskrives som sådan i
  rapporten.
  
\item I kan antage, at læseren af rapporten er bekendt med pensum til
  kurset, og I kan frit henvise til kursusbøger, noter og
  opgavetekster.

\item Hver gang I har ændret i et modul af oversætteren, så genoversæt
  hele oversætteren (med {\tt source compile.sh}).  Dog kan advarsler
  om ``pattern matching is not exhaustive'' i reglen ignoreres indtil
  alle moduler er udvidede.
  
\item Når man oversætter signaturen til den genererede parser, vil
  {\tt mosmlc} give en ``Compliance Warning''. Denne er uden
  betydning, og kan ignoreres.

\item Når I udvider lexeren, skal I erklære de nye tokens i parseren
  med {\tt \%token} erklæringer og derefter generere parseren og
  oversætte den {\em inden} i oversætter lexeren, ellers vil I få
  typefejl.
  
\item I lexerdefinitionen skal enkelttegn stå i {\em backquotes} ({\tt
    `}), {\em ikke} almindelige anførselstegn ({\tt '}), som i C eller
  Java.  Det er tilladt at bruge dobbelte anførslestegn (\verb`"`)
  også om enkelttegn.

\item I kan bruge ML-funktionerne \texttt{String.toCString} og
  \texttt{String.fromCString} til at indsætte og afkode
  escapesekvenser i stringkonstanter og \texttt{Char.toCString} og
  \texttt{Char.fromCString} til ditto for tegnkonstanter.  De kan også
  bruges til at checke, om escapesekvenser i tegn- og stringkonstanter
  er lovlige.  MARS bruger C's escapesekvenser i f.eks.\
  \texttt{.asciiz} direktivet.

\end{itemize}

\end{document}


